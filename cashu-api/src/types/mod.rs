use anyhow::{Error, Result};
use cashu_sdk::{
    types::{InvoiceStatus, KeysetInfo},
    Amount, Bolt11Invoice, Sha256, nuts::Proof, secret::Secret, mint::Mint,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LnMessage {
    PaymentReceived,
}

/// Possible states of an invoice
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum InvoiceTokenStatus {
    Issued,
    NotIssued,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvoiceInfo {
    /// Payment hash of LN Invoice
    pub payment_hash: Sha256,
    /// random hash generated by the mint to internally look up the invoice state
    pub hash: Sha256,
    pub invoice: Bolt11Invoice,
    pub amount: Amount,
    pub status: InvoiceStatus,
    pub token_status: InvoiceTokenStatus,
    pub memo: String,
    pub confirmed_at: Option<u64>,
    pub mint_id: Option<String>,
}

impl InvoiceInfo {
    pub fn new(
        payment_hash: Sha256,
        hash: Sha256,
        invoice: Bolt11Invoice,
        amount: Amount,
        status: InvoiceStatus,
        memo: &str,
        confirmed_at: Option<u64>,
        mint_id: Option<String>,
    ) -> Self {
        Self {
            payment_hash,
            hash,
            invoice,
            amount,
            status,
            token_status: InvoiceTokenStatus::NotIssued,
            memo: memo.to_string(),
            confirmed_at,
            mint_id,
        }
    }

    pub fn as_json(&self) -> Result<String, Error> {
        Ok(serde_json::to_string(self)?)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct MintInfo {
    pub name: Option<String>,
    pub version: Option<String>,
    pub description: Option<String>,
    pub description_long: Option<String>,
    pub contact: Option<HashMap<String, String>>,
    pub nuts: Option<Vec<String>>,
    pub motd: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct StoredMint {
    pub name: String,
    pub version: Option<String>,
    pub description: Option<String>,
    pub description_long: Option<String>,
    pub contact: Option<HashMap<String, String>>,
    pub nuts: Option<Vec<String>>,
    pub motd: Option<String>,
    pub secret: Option<String>,
    pub derivation_path: Option<String>,
    pub active_keyset: Option<String>,
    pub keysets_info: Option<Vec<KeysetInfo>>,
    pub in_circulation_msat: u64,
    pub spend_secrets: Option<Vec<Secret>>,
    pub max_order: Option<u8>,
    pub min_fee_reserve_msat: Option<u64>,
    pub percent_fee_reserve: Option<f32>
}

impl Into<Mint> for StoredMint {
    fn into(self) -> Mint {
        Mint::new(
            self.secret.unwrap().as_str(),
            self.derivation_path.unwrap().as_str(),
            self.keysets_info.unwrap().into_iter().map(|k| k).collect(),
            self.spend_secrets
                .unwrap_or_default()
                .into_iter()
                .map(|s| s)
                .collect(),
                self.max_order.unwrap(),
            Amount::from_msat(self.min_fee_reserve_msat.unwrap()),
            self.percent_fee_reserve.unwrap(),
        )
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsedProof {
    pub mint_id: String,
    pub proof: Proof,
}